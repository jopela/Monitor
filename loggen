#!/usr/bin/python2

import argparse

from time import ctime
from datetime import timedelta

def main():
    """Entry point for loggen."""

    parser = argparse.ArgumentParser('Generate an html report from a component'\
            ' monitor log file')

    parser.add_argument(
            '-l',
            '--log',
            help='log file path (default is: /var/log/monitor/monitor.log)',
            type=str,
            default='/var/log/monitor/monitor.log'
            )

    parser.add_argument(
            '-t',
            '--template',
            help='report template file path (default is: /etc/monitor/monitor'\
                    '.mako)',
            type=str,
            default='/etc/monitor/monitor.mako'
            )

    args = parser.parse_args()

    start, last = get_acquisition_period(args.log)
    uptime = get_uptime_percentage(args.log)
    longest = get_longest_uptime(args.log)
    longest_downtime = get_longest_downtime(args.log)

    print start
    print last
    print uptime
    print longest
    print longest_downtime
    print get_failures_timestamps(args.log)
    print get_mtbf(args.log)

    return

def get_acquisition_period(log_path):
    """Get the acquisition period (start date and last date) from the log file
    and return a tuple of the form (start_date,last_date)."""

    start_date = None
    last_date = None

    with open(log_path,'r') as log_f:
        for i, val in enumerate(log_f):
            if i == 0:
                timestamp = int(val.split(':')[0])
                start_date =  ctime(timestamp)

            last = val

        timestamp = int(last.split(':')[0])
        last_date = ctime(timestamp)

    return (start_date, last_date)

def get_uptime_percentage(log_path):
    """Compute the uptime percentage from the log file and return it."""

    total_uptime = 0
    total_time = 0
    prev_timestamp = None
    current_timestamp = None

    first_timestamp = None
    last_timestamp = None

    with open(log_path, 'r') as log_f:
        for i, val in enumerate(log_f):
            if i == 0:
                first_timestamp = int(val.split(':')[0])
                prev_timestamp = first_timestamp
                continue

            current_timestamp = int(val.split(':')[0])
            state = int(val.split(':')[1])

            if state == 0:
                total_uptime += current_timestamp - prev_timestamp

            prev_timestamp = current_timestamp

        last_timestamp = current_timestamp

        total_time = last_timestamp - first_timestamp
        uptime = float(total_uptime) / float(total_time)

    return uptime * 100

def get_longest_uptime(log_path):
    """Compute the longest uptime and returns it in a human readable form."""

    max_uptime = 0
    current_uptime = 0
    previous_timestamp = 0

    with open(log_path, 'r') as log_f:
        for i, val in enumerate(log_f):
            if i == 0:
                previous_timestamp = int(val.split(':')[0])
                continue

            current_timestamp = int(val.split(':')[0])
            state = int(val.split(':')[1])

            if state == 0:
                current_uptime += current_timestamp - previous_timestamp
            else:
                max_uptime = max(max_uptime, current_uptime)
                current_uptime = 0

            previous_timestamp = current_timestamp

    max_uptime = max(current_uptime, max_uptime)

    human_max_uptime = timedelta(seconds=max_uptime)

    return human_max_uptime
# TODO: get_longest_downtime and get_longest_uptime are almost the same
# functions. This mus be refactored somehow.

def get_longest_downtime(log_path):
    """ Compute the longest downtime and returns it in a human readable form."""
    max_uptime = 0
    current_uptime = 0
    previous_timestamp = 0

    with open(log_path, 'r') as log_f:
        for i, val in enumerate(log_f):
            if i == 0:
                previous_timestamp = int(val.split(':')[0])
                continue

            current_timestamp = int(val.split(':')[0])
            state = int(val.split(':')[1])

            if state != 0:
                current_uptime += current_timestamp - previous_timestamp
            else:
                max_uptime = max(max_uptime, current_uptime)
                current_uptime = 0

            previous_timestamp = current_timestamp

    max_uptime = max(current_uptime, max_uptime)

    human_max_uptime = timedelta(seconds=max_uptime)

    return human_max_uptime

def get_failures_timestamps(log_path):
    """Puts the timestamps of failures in a list and return that list."""

    failure_timestamps = []

    previous_state = None

    with open(log_path,'r') as log_f:
        for i, val in enumerate(log_f):
            if i == 0:
                previous_state = int(val.split(':')[1])
                continue

            current_state = int(val.split(':')[1])

            if current_state != 0 and previous_state == 0:
                timestamp = int(val.split(':')[0])
                failure_timestamps.append(timestamp)

            previous_state = current_state

    return failure_timestamps

def get_mtbf(log_path):
    """Compute the mean time between failure and return it in a human
    readable form."""

    timestamps = get_failures_timestamps(log_path)

    if len(timestamps) > 1:
        time_between_failures = []
        previous = timestamps[0]

        for i in timestamps[1:]:
            time_between_failures.append(i-previous)
            previous = i

        mtbf = float(sum(time_between_failures)) / len(time_between_failures)
    else:
        mtbf = 0 

    return timedelta(seconds=int(mtbf))

if __name__ == '__main__':
    main()
